#!/usr/bin/env bash
set -o errtrace  # -E trap inherited in sub script
set -o errexit   # -e
set -o functrace # -T If set, any trap on DEBUG and RETURN are inherited by shell functions
set -o pipefail  # default pipeline status==last command status, If set, status=any command fail

SHAS_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
cd "$SHAS_DIR"

# shellcheck disable=SC1091
source "./common.bash"

# ############################################################
# 基于bash脚本的mono项目管理
# 1. 名词:workspace/project/子项目,名词等同
# 2. shas脚本为根脚本，主要是遍历多个项目执行命令，而各子项目的sha执行实际本项目命令
# 3. 项目组是相同体系规范的一组项目容器，可共享命令实现，
#    比如定义一个npm组，build命令只需要写一次就可以被所有npm项目使用，除非项目本身对build命令有其特殊实现，可覆盖之
# 4. 多项目命令的实现和执行分3个层级：shas -> 项目组-> 项目
#    比如执行'shas build'，先循环一组项目，每个项目加载其所属项目组build函数，再加载项目自己sha脚本build函数，
#    利用bash脚本后定义的函数可覆盖先定义的函数的特性，如果项目的sha脚本没有build函数实现，就执行项目组的build函数，
#    否则，执行项目自己的build函数。
# 5. 项目定义时按相对路径或绝对路径，其作为项目过滤的依据
#############################################################
declare -a __project_group_pnpm=(
.
./packages/core
./packages/provider-tencentcloud
./packages/cli
)
declare -a __project_group_other=()

declare -a __project_array=("${__project_group_other[@]}"  "${__project_group_pnpm[@]}")

# 当前待处理的项目数组，暂时全部，回头加过滤器
declare -a __current_project_array=("${__project_array[@]}")

__current_projects() { printf "%s\n" "${__current_project_array[@]}";}

# Usage: __run_project_cmd <project> <cmd>
# 本函数做多次加载相关项目的命令集，外部执行时最好用子进程形式执行：( __run_project_cmd "project" "cmd" )
__run_project_cmd(){
  local project="$1"
  local cmd="$2"
  if [[ "$project" == "" ]]; then echo "ERROR: 缺少<project>参数,Usage: __run_project_cmd <project> <cmd>"; fi
  if [[ "$cmd" == "" ]];     then echo "ERROR: 缺少<cmd>参数,Usage: __run_project_cmd <project> <cmd>"; fi

  shift 2
  local before_load
  before_load=$(declare -f $cmd)

  cd "$project"

  for n in "${__project_group_pnpm[@]}"; do
    if [[ "$project" == "$n" ]]; then
      _project_group_pnpm_on
      break;
    fi
  done

  ## load cmd function from project
  if [ -f "./sha" ]; then
    . "./sha"
  fi

  local after_load
  after_load=$(declare -f "$cmd")
  # 如果cmd的函数加载前后内容相同，说明用户并为定义相关函数，则忽略执行
  if [[ "$before_load" == "$after_load" ]]; then
    echo "  ⚪️ignore 项目 $project 执行 $cmd, 因为您未定义[$cmd]函数实现"
    return 0
  fi
  # 执行相应的命令函数
#  echo "run: $after_load"
  $cmd "$@"
}

__run__current_projects() {
  local cmd="$1"
  if [[ "$cmd" == "" ]];     then echo "ERROR: 缺少<cmd>参数,Usage: __run__current_projects <cmd>"; fi

  local project_dir;
  for project_dir in "${__current_project_array[@]}"; do
    # 用()建立子进程，执行时互不干扰
    (
        echo "🟪 project: $project_dir"
        __run_project_cmd "$project_dir" "$cmd" "$@"
    )
  done
}


##########################################
# app cmd script
# 应用的命令脚本
##########################################

exec() {
  for project_dir in "${__current_project_array[@]}"; do
    echo "😀project: '$project_dir'"
    cd "$SHAS_DIR/$project_dir"
    _run "$@"
    echo
  done
}

clean() {          __run__current_projects "clean"         "$@";}
install() {        __run__current_projects "install"       "$@";}
build() {          __run__current_projects "build"         "$@";}
pack() {           __run__current_projects "pack"          "$@";}
test() {           __run__current_projects "test"          "$@";}
clean_build() {    __run__current_projects "clean_build"   "$@";}
clean_test() {     __run__current_projects "clean_test"    "$@";}
clean_pack() {     __run__current_projects "clean_pack"    "$@";}


# npm 名字和已有命令重复
npmjs() {
  login() {
    # 指定--registry防止登陆跳转到镜像网站
    npm login --registry=https://registry.npmjs.org/
  }
}

status() {
  echo "## workspaces:"
  printf "  %s\n" "${__project_array[@]}"
  echo "## packages:"
  printf "  %s\n" "$(_dir_to_package_name "${__project_array[@]}")"
  echo "## out ip:"
  echo "  $(curl ipinfo.io/ip 2>/dev/null)"
}

version() {
  info() { npm version --workspaces "$@"; }
  patch() { npm version patch --workspaces "$@"; }
  prerelease() { npm version prerelease --workspaces "$@";}
  push() {  git push origin --tags  "$@" ; }
}


# 守卫语句，当'source ./sha'执行，脚本被当类库导入时，$0为bash或zsh等值
# 即当类库引用时不执行后续命令式入口代码
if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
  echo 'shas脚本为mono项目脚本，不能作为类库导入，只能命令式执行'
  exit 1
fi

# 当脚本被直接执行的入口代码
sha "$@"
